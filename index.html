<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pleiades Peripheral Vision POV (Three.js)</title>
    <style>
        /* Import the Average font from Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Average&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* Solid black background for Three.js */
            cursor: none; /* Hide the default cursor when in simulation (desktop) */
            font-family: 'Average', serif;
            color: rgba(255, 255, 255, 0.98);
            text-align: center;
            touch-action: none; /* Prevent touch delay and default touch actions */
        }

        /* The Three.js canvas will fill the viewport */
        canvas {
            display: block;
        }

        /* Overlay container for HTML elements - Now the main click target */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto; /* Allow mouse/touch events on the overlay */
            z-index: 10; /* Ensure overlay is above the canvas */
        }

        /* Styling for the title text */
        .title {
            position: absolute;
            /* Initial position will be set by JS to center, then transformed */
            color: rgba(255, 255, 255, 1); /* Full white for text */
            font-size: 1.6em; /* Slightly larger font size */
            text-align: center; /* Center align text */
            pointer-events: none; /* Allow mouse events/touches to pass through */
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8); /* Stronger text glow */
            /* Smooth transition for position */
            transition: transform 0.1s linear; /* Added transition for smoother movement */
            white-space: nowrap; /* Prevent text wrapping */
            /* Initial centering */
            left: 50%;
            top: 50px; /* Initial top offset */
            transform: translateX(-50%);
             font-family: 'Average', serif; /* Changed font to Average */
        }

        /* Message to guide the user */
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em;
            z-index: 20; /* Ensure message is on top of other overlays */
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            background-color: rgba(0, 0, 0, 0.8); /* More opaque background */
            padding: 20px;
            border-radius: 10px;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
             font-family: 'Average', serif; /* Changed font to Average */
             pointer-events: auto; /* Make message interactive for click */
        }

        .message.hidden {
            opacity: 0;
            pointer-events: none; /* Hide and make non-interactive when hidden */
        }

        /* Styling for developer credits */
        .credits {
            position: fixed; /* Fixed position relative to the viewport */
            bottom: 20px; /* Distance from the bottom */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust for exact centering */
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6); /* Subtle color */
            z-index: 20; /* Ensure credits are on top of other overlays */
            pointer-events: none; /* Not interactive */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease-in-out; /* Smooth fade transition */
            font-family: 'Average', serif; /* Changed font to Average */
        }

        .credits.visible {
            opacity: 1; /* Visible state */
        }

        /* Visual indicator for the fovea area (2D overlay) */
        .fovea-indicator {
            position: fixed; /* Fixed position relative to the viewport */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center the element */
            width: var(--fovea-indicator-size); /* Size based on foveaRadius */
            height: var(--fovea-indicator-size); /* Size based on foveaRadius */
            border: 1px dashed rgba(255, 255, 255, 0.2); /* Subtle dashed border */
            border-radius: 50%; /* Make it a circle */
            pointer-events: none; /* Not interactive */
            z-index: 15; /* Above stars, below messages */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease-in-out; /* Smooth fade */
        }

        .fovea-indicator.visible {
            opacity: 1; /* Visible state */
        }

        /* Settings Panel Styling */
        .settings-panel {
            position: fixed;
            top: 50%;
            right: 20px; /* Distance from the right edge */
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.85); /* Dark, semi-transparent background */
            padding: 20px;
            border-radius: 10px;
            z-index: 20; /* Ensure panel is on top */
            color: rgba(255, 255, 255, 0.9);
            max-height: 80vh; /* Limit height */
            overflow-y: auto; /* Add scrolling if content overflows */
            pointer-events: auto; /* Make panel interactive */
            opacity: 0; /* Hidden by default */
            visibility: hidden; /* Also hide from screen readers when not visible */
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            width: 250px; /* Fixed width */
            text-align: left;
        }

        .settings-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .settings-panel h3 {
            margin-top: 0;
            color: rgba(255, 255, 255, 1);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .settings-panel label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
        }

        .settings-panel input[type="range"],
        .settings-panel input[type="number"] {
            display: block;
            width: 100%;
            margin-bottom: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 3px;
            padding: 5px;
            color: rgba(255, 255, 255, 0.9);
        }

         .settings-panel input[type="number"] {
             width: calc(100% - 12px); /* Adjust width for padding */
         }

        .settings-panel button {
            display: block;
            width: 100%;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            margin-top: 10px;
        }

        .settings-panel button:hover {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .settings-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 20; /* Ensure toggle is on top */
            background-color: rgba(0, 0, 0, 0.7);
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.9em;
            pointer-events: auto; /* Make toggle interactive */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }

         .settings-toggle:hover {
            background-color: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.5);
         }


    </style>
</head>
<body>
    <div id="threejs-container"></div>

    <audio id="background-music" loop>
        <source src="saitama v5.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <div class="overlay" id="main-container">
        <div class="title" id="main-title">Not focusing sometimes allows you to see what is in front of you.<br>The Pleiades appear clearer in your peripheral vision.</div>
        <div class="message" id="user-message">
            Click anywhere to start<br>Press ESC to stop
        </div>
        <div class="credits" id="developer-credits">
            Developed by Justin Moran
        </div>
        <div class="fovea-indicator" id="fovea-indicator"></div>
    </div>

    <div class="settings-panel" id="settings-panel">
        <h3>Settings</h3>

        <label for="num-stars">Number of Stars:</label>
        <input type="number" id="num-stars" value="10000" min="100" max="50000">

        <label for="star-field-size">Star Field Size:</label>
        <input type="number" id="star-field-size" value="2000" min="100" max="10000">

        <label for="fovea-radius">Fovea Radius:</label>
        <input type="range" id="fovea-radius" min="50" max="1000" value="150">
        <span id="fovea-radius-value">150</span> px

        <label for="peripheral-brightness">Peripheral Brightness:</label>
        <input type="range" id="peripheral-brightness" min="0" max="100" value="100">
        <span id="peripheral-brightness-value">1.0</span>

        <label for="foveated-dimness">Foveated Dimness:</label>
        <input type="range" id="foveated-dimness" min="0" max="100" value="5">
        <span id="foveated-dimness-value">0.05</span>

        <label for="mouse-sensitivity">Mouse Sensitivity:</label>
        <input type="range" id="mouse-sensitivity" min="1" max="100" value="2">
        <span id="mouse-sensitivity-value">0.002</span>

        <label for="touch-sensitivity">Touch Sensitivity:</label>
        <input type="range" id="touch-sensitivity" min="1" max="100" value="5">
        <span id="touch-sensitivity-value">0.005</span>

         <label for="title-parallax">Title Parallax:</label>
        <input type="range" id="title-parallax" min="0" max="100" value="15">
        <span id="title-parallax-value">0.15</span>

        <label for="music-volume">Music Volume:</label>
        <input type="range" id="music-volume" min="0" max="100" value="50"> <span id="music-volume-value">0.50</span>

        <button id="apply-settings">Apply Settings</button>
    </div>

    <div class="settings-toggle" id="settings-toggle">Settings</div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Wait for the DOM to be fully loaded before running the script
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded fired. Script is running.');

            // Get necessary HTML elements
            const mainContainer = document.getElementById('main-container'); // Now correctly gets the overlay div
            const threejsContainer = document.getElementById('threejs-container');
            const overlay = document.getElementById('overlay'); // This will now be the same as mainContainer
            const mainTitle = document.getElementById('main-title');
            const userMessage = document.getElementById('user-message');
            const developerCredits = document.getElementById('developer-credits');
            const backgroundMusic = document.getElementById('background-music');
            const foveaIndicator = document.getElementById('fovea-indicator');
            const settingsPanel = document.getElementById('settings-panel');
            const settingsToggle = document.getElementById('settings-toggle');

            // Get settings input elements and value displays
            const numStarsInput = document.getElementById('num-stars');
            const starFieldSizeInput = document.getElementById('star-field-size');
            const foveaRadiusInput = document.getElementById('fovea-radius');
            const foveaRadiusValue = document.getElementById('fovea-radius-value');
            const peripheralBrightnessInput = document.getElementById('peripheral-brightness');
            const peripheralBrightnessValue = document.getElementById('peripheral-brightness-value');
            const foveatedDimnessInput = document.getElementById('foveated-dimness');
            const foveatedDimnessValue = document.getElementById('foveated-dimness-value');
            const mouseSensitivityInput = document.getElementById('mouse-sensitivity');
            const mouseSensitivityValue = document.getElementById('mouse-sensitivity-value');
            const touchSensitivityInput = document.getElementById('touch-sensitivity');
            const touchSensitivityValue = document.getElementById('touch-sensitivity-value');
             const titleParallaxInput = document.getElementById('title-parallax');
            const titleParallaxValue = document.getElementById('title-parallax-value');
            const musicVolumeInput = document.getElementById('music-volume');
            const musicVolumeValue = document.getElementById('music-volume-value');
            const applySettingsButton = document.getElementById('apply-settings');


            // Three.js variables
            let scene, camera, renderer, starsGeometry, starsMaterial, starField;

            // Configuration variables (will be updated by settings)
            let numberOfStars = parseInt(numStarsInput.value); // Initial value from input
            let starFieldSize = parseFloat(starFieldSizeInput.value); // Initial value from input
            let foveaRadius = parseFloat(foveaRadiusInput.value); // Initial value from input
            let baseOpacity = parseFloat(peripheralBrightnessInput.value) / 100; // Initial value from input (scaled)
            let minOpacity = parseFloat(foveatedDimnessInput.value) / 100; // Initial value from input (scaled)
            let mouseSensitivity = parseFloat(mouseSensitivityInput.value) / 1000; // Initial value from input (scaled)
            let touchSensitivity = parseFloat(touchSensitivityInput.value) / 1000; // Initial value from input (scaled)
            let titleParallaxMultiplier = parseFloat(titleParallaxInput.value) / 100; // Initial value from input (scaled)
            // Music volume is handled separately


            // Simulated view rotation (using Euler angles for simplicity in this example)
            let viewRotationX = 0;
            let viewRotationY = 0;

            // Variable to track the last touch position
            let lastTouchX = null;
            let lastTouchY = null;

            // Flag to check if it's likely a touch device
            const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);

            // --- Three.js Initialization ---
            function initThreeJS() {
                console.log('Initializing Three.js...');
                // Create a scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000); // Black background

                // Create a camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 0.1; // Start slightly into the scene

                // Create a renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                // Clear previous canvas if it exists
                while (threejsContainer.firstChild) {
                    threejsContainer.removeChild(threejsContainer.firstChild);
                }
                threejsContainer.appendChild(renderer.domElement);

                 // Dispose of previous star field if it exists
                 if (starField) {
                     scene.remove(starField);
                     starsGeometry.dispose();
                     starsMaterial.dispose();
                     console.log('Disposed of previous star field.');
                 }


                // Create star geometry (using BufferGeometry for performance)
                starsGeometry = new THREE.BufferGeometry();
                const positions = [];
                const opacities = []; // Store initial opacity for each star

                for (let i = 0; i < numberOfStars; i++) {
                    // Random position within the star field cube
                    const x = (Math.random() - 0.5) * starFieldSize;
                    const y = (Math.random() - 0.5) * starFieldSize;
                    const z = (Math.random() - 0.5) * starFieldSize;
                    positions.push(x, y, z);

                    // Store initial opacity (can be varied based on position/depth if desired)
                    opacities.push(baseOpacity); // Start with full base opacity
                }

                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                starsGeometry.setAttribute('opacity', new THREE.Float32BufferAttribute(opacities, 1));

                console.log(`Created ${numberOfStars} stars.`);


                // Create star material
                starsMaterial = new THREE.PointsMaterial({
                    color: 0xffffff, // White stars
                    size: 2, // Pixel size of stars
                    sizeAttenuation: false, // Stars maintain pixel size regardless of distance
                    transparent: true,
                    opacity: 1.0, // Base opacity controlled by vertex attribute
                    vertexColors: false // We'll handle opacity per vertex
                });

                 // Custom shader to use vertex opacity
                 starsMaterial.onBeforeCompile = (shader) => {
                     shader.vertexShader = shader.vertexShader.replace(
                         '#include <common>',
                         `
                         #include <common>
                         attribute float opacity;
                         varying float vOpacity;
                         `
                     );
                     shader.vertexShader = shader.vertexShader.replace(
                         '#include <fog_vertex>',
                         `
                         #include <fog_vertex>
                         vOpacity = opacity;
                         `
                     );
                     shader.fragmentShader = shader.fragmentShader.replace(
                         'gl_FragColor = vec4( diffuse, opacity );',
                         'gl_FragColor = vec4( diffuse, vOpacity );'
                     );
                 };


                // Create the star field Points object
                starField = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(starField);

                // Add background elements (as simple spheres for now) - Only add once
                 if (scene.children.filter(c => c.userData.isBackgroundElement).length === 0) {
                    console.log('Adding background elements...');
                    const backgroundElementGeometry = new THREE.SphereGeometry(1, 32, 32);
                    const backgroundElementMaterial = new THREE.MeshBasicMaterial({
                         color: 0xffffff,
                         transparent: true,
                         opacity: 0.02, // Very faint
                         blending: THREE.AdditiveBlending // Subtle glow effect
                    });

                    for (let i = 0; i < numberOfBackgroundElements; i++) {
                         const element = new THREE.Mesh(backgroundElementGeometry, backgroundElementMaterial.clone()); // Clone material to vary opacity/color later if needed
                         element.userData.isBackgroundElement = true; // Mark as background element
                         // Position far away
                         element.position.set(
                             (Math.random() - 0.5) * starFieldSize * 2,
                             (Math.random() - 0.5) * starFieldSize * 2,
                             (Math.random() - 0.5) * starFieldSize * 2
                         );
                         // Scale randomly
                         const scale = 50 + Math.random() * 100;
                         element.scale.set(scale, scale, scale);
                         scene.add(element);

                         // Store initial position for animation
                         element.userData.initialPosition = element.position.clone();
                         element.userData.driftSpeed = 0.001 + Math.random() * 0.002;
                         element.userData.driftDirection = new THREE.Vector3(
                             (Math.random() - 0.5),
                             (Math.random() - 0.5),
                             (Math.random() - 0.5)
                         ).normalize();
                    }
                 }


                // Initial render
                renderer.render(scene, camera);
                console.log('Initial Three.js render complete.');

                // Start the animation loop if not already running
                if (!animationFrameId) {
                    console.log('Starting animation loop.');
                    animate();
                }
            }

            // Animation frame ID for stopping/starting the loop
            let animationFrameId = null;

            // --- Animation Loop ---
            function animate() {
                animationFrameId = requestAnimationFrame(animate);

                // Update star opacities based on distance to the center of the screen
                updateStarOpacities();

                // Update background element positions for slow drift
                scene.children.forEach(child => {
                    if (child.userData.isBackgroundElement && child.userData.initialPosition) {
                        const time = performance.now() * child.userData.driftSpeed;
                        child.position.copy(child.userData.initialPosition).add(
                            child.userData.driftDirection.clone().multiplyScalar(Math.sin(time))
                        );
                    }
                });


                // Render the scene
                renderer.render(scene, camera);
            }

            // --- Update Star Opacities based on Fovea ---
            function updateStarOpacities() {
                if (!starsGeometry || !camera) return; // Ensure geometry and camera exist

                const positions = starsGeometry.attributes.position.array;
                const opacities = starsGeometry.attributes.opacity.array;
                const vector = new THREE.Vector3();


                for (let i = 0; i < numberOfStars; i++) {
                    vector.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);

                    // Calculate the distance from the star to the center of the screen in 2D screen space
                    // We need to project the 3D star position to 2D screen coordinates
                    vector.project(camera); // Project star position to normalized device coordinates (-1 to 1)

                    // Convert normalized device coordinates to pixel coordinates
                    const screenX = (vector.x + 1) / 2 * window.innerWidth;
                    const screenY = (1 - vector.y) / 2 * window.innerHeight; // Y is inverted in screen coordinates

                    // Calculate distance from the star's screen position to the center of the screen (pixel 0,0 relative to center)
                    const distanceToCenter = Math.sqrt(Math.pow(screenX - window.innerWidth / 2, 2) + Math.pow(screenY - window.innerHeight / 2, 2));

                    let opacity;
                    // Check if the star is within the fovea radius of the screen center
                    if (distanceToCenter < foveaRadius) {
                        // Calculate opacity inversely proportional to distance within the radius
                        // Closer to center = less opaque (more dim)
                        opacity = minOpacity + (baseOpacity - minOpacity) * (distanceToCenter / foveaRadius);
                        // Ensure opacity stays within the min/base range
                        opacity = Math.min(baseOpacity, Math.max(minOpacity, opacity));
                    } else {
                        // If outside the fovea radius, set to base opacity (more visible)
                        opacity = baseOpacity;
                    }

                    // Apply the calculated opacity to the vertex attribute
                    opacities[i] = opacity;
                }

                // Mark the opacity attribute as needing an update
                starsGeometry.attributes.opacity.needsUpdate = true;
            }


            // --- Input Event Handling (Mouse & Touch) ---

            // Handle mouse movement (desktop) when pointer is locked
            function handleMouseMove(event) {
                // Accumulate mouse delta for camera rotation
                viewRotationY -= event.movementX * mouseSensitivity;
                viewRotationX -= event.movementY * mouseSensitivity;

                // Clamp vertical rotation to prevent flipping
                viewRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, viewRotationX));

                // Apply rotation to the camera
                camera.rotation.set(viewRotationX, viewRotationY, 0, 'YXZ'); // Use YXZ order to avoid gimbal lock initially

                // Update HTML element positions based on view rotation
                updateHtmlElementPositions();
            }

            // Handle touch start (mobile)
            function handleTouchStart(event) {
                 if (event.touches.length === 1) {
                    // Prevent default touch actions like scrolling/zooming
                    event.preventDefault();
                    // Record the starting touch position
                    lastTouchX = event.touches[0].clientX;
                    lastTouchY = event.touches[0].clientY;
                    // Hide the message on first touch
                    userMessage.classList.add('hidden');

                     // Attempt to play music on the first touch (addresses autoplay policies)
                    backgroundMusic.play().catch(error => {
                        console.error('Failed to play music on touch:', error);
                        // Handle potential Autoplay Policy issues
                    });
                 }
            }

            // Handle touch move (mobile)
            function handleTouchMove(event) {
                if (event.touches.length === 1 && lastTouchX !== null) {
                     // Prevent default touch actions
                     event.preventDefault();

                    // Calculate touch delta movements
                    const deltaX = event.touches[0].clientX - lastTouchX;
                    const deltaY = event.touches[0].clientY - lastTouchY;

                    // Accumulate touch delta for camera rotation, scaled by sensitivity
                    viewRotationY -= deltaX * touchSensitivity;
                    viewRotationX -= deltaY * touchSensitivity;

                    // Clamp vertical rotation
                    viewRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, viewRotationX));

                    // Apply rotation to the camera
                    camera.rotation.set(viewRotationX, viewRotationY, 0, 'YXZ');

                    // Update the last touch position
                    lastTouchX = event.touches[0].clientX;
                    lastTouchY = event.touches[0].clientY;

                     // Update HTML element positions based on view rotation
                    updateHtmlElementPositions();
                }
            }

            // Handle touch end (mobile)
            function handleTouchEnd(event) {
                // Reset last touch position
                lastTouchX = null;
                lastTouchY = null;
                 // If all touches ended, you might want to pause/stop movement or handle multi-touch gestures
            }

            // Update positions of 2D HTML elements based on camera rotation
            function updateHtmlElementPositions() {
                 const centerX = window.innerWidth / 2;
                 const centerY = window.innerHeight / 2;

                 // Calculate the position of the title relative to the center of the view
                 // This is simplified - for perfect alignment with a point in 3D space,
                 // you would project a 3D point to 2D. This approach simulates it.
                 const newTitleX = centerX + (-viewRotationY) * titleParallaxMultiplier * window.innerWidth;
                 const newTitleY = centerY + (-viewRotationX) * titleParallaxMultiplier * window.innerHeight;

                 // Apply transform for smoother movement and centering
                 mainTitle.style.left = `${newTitleX}px`;
                 mainTitle.style.top = `${newTitleY}px`;
                 mainTitle.style.transform = `translate(-50%, -50%)`; // Keep centered on its calculated point
            }


            // --- Pointer Lock API Implementation (Desktop) ---

            // Request pointer lock on click (primarily for desktop)
            mainContainer.addEventListener('click', () => {
                console.log('Container clicked. Attempting to start simulation.');
                // Always attempt to hide the message and play music on any click
                userMessage.classList.add('hidden');
                backgroundMusic.play().catch(error => {
                    console.error('Failed to play music on click:', error);
                    // Handle potential Autoplay Policy issues - maybe show a "Play Music" button
                });

                // If it's likely NOT a touch device, request pointer lock
                if (!isTouchDevice) {
                    mainContainer.requestPointerLock();
                }
                 // On touch devices, the touchstart handler already handles the initial interaction
            });

            // Handle pointer lock change event
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === mainContainer) {
                    console.log('Pointer Lock: Locked');
                    // Set music volume to full (based on settings) when locked
                    backgroundMusic.volume = parseFloat(musicVolumeInput.value) / 100;
                    // Add desktop mousemove listener
                    document.addEventListener('mousemove', handleMouseMove, false);
                    // Hide fovea indicator on desktop when locked
                    foveaIndicator.classList.remove('visible');
                    // Hide settings panel when simulation starts
                     settingsPanel.classList.remove('visible');
                } else {
                    console.log('Pointer Lock: Unlocked');
                    // Show the message when unlocked (only if not a touch device, touch devices keep it hidden)
                     if (!isTouchDevice) {
                         userMessage.classList.remove('hidden');
                     }
                    // Set music volume to half when unlocked
                    backgroundMusic.volume = (parseFloat(musicVolumeInput.value) / 100) / 2;
                    // Pause background music when unlocked (if you want it to stop entirely)
                    // backgroundMusic.pause();
                    // Remove desktop mousemove listener
                    document.removeEventListener('mousemove', handleMouseMove, false);
                    // Reset view rotation when exiting lock (optional, can be kept)
                    // viewRotationX = 0;
                    // viewRotationY = 0;
                    // camera.rotation.set(viewRotationX, viewRotationY, 0, 'YXZ');
                    // updateHtmlElementPositions();
                     // Show fovea indicator on desktop when unlocked (optional, or keep hidden)
                     // if (!isTouchDevice) {
                     //    foveaIndicator.classList.add('visible');
                     // }
                }
            }, false);

            // Handle pointer lock error
            document.addEventListener('pointerlockerror', () => {
                console.error('Pointer Lock: Error acquiring pointer lock.');
                 userMessage.textContent = 'Error acquiring pointer lock. Please try again.';
                 // On desktop, if pointer lock fails, maybe show the message again or provide alternative instructions
                 if (!isTouchDevice) {
                     userMessage.classList.remove('hidden');
                 }
            }, false);


            // --- Keyboard Event Listener for Credits and Settings Toggle ---
            document.addEventListener('keydown', (event) => {
                // Check if the pressed key is 'c' for credits
                if (event.key === 'c') {
                    developerCredits.classList.toggle('visible'); // Toggle visibility regardless of pointer lock
                }
                 // Check if the pressed key is 's' for settings (or another key if 's' is needed for movement later)
                 if (event.key === 's' && document.pointerLockElement !== mainContainer) {
                     settingsPanel.classList.toggle('visible');
                 }
            });

            // --- Settings Panel Functionality ---

            // Update value displays when sliders are moved
            foveaRadiusInput.addEventListener('input', () => {
                foveaRadiusValue.textContent = foveaRadiusInput.value;
            });
             peripheralBrightnessInput.addEventListener('input', () => {
                peripheralBrightnessValue.textContent = (peripheralBrightnessInput.value / 100).toFixed(2);
            });
             foveatedDimnessInput.addEventListener('input', () => {
                foveatedDimnessValue.textContent = (foveatedDimnessInput.value / 100).toFixed(2);
            });
             mouseSensitivityInput.addEventListener('input', () => {
                mouseSensitivityValue.textContent = (mouseSensitivityInput.value / 1000).toFixed(3);
            });
             touchSensitivityInput.addEventListener('input', () => {
                touchSensitivityValue.textContent = (touchSensitivityInput.value / 1000).toFixed(3);
            });
             titleParallaxInput.addEventListener('input', () => {
                titleParallaxValue.textContent = (titleParallaxInput.value / 100).toFixed(2);
            });
             musicVolumeInput.addEventListener('input', () => {
                musicVolumeValue.textContent = (musicVolumeInput.value / 100).toFixed(2);
                backgroundMusic.volume = musicVolumeInput.value / 100; // Update volume immediately
            });


            // Apply settings button click handler
            applySettingsButton.addEventListener('click', () => {
                console.log('Applying settings...');
                // Update configuration variables from input values
                numberOfStars = parseInt(numStarsInput.value);
                starFieldSize = parseFloat(starFieldSizeInput.value);
                foveaRadius = parseFloat(foveaRadiusInput.value);
                baseOpacity = parseFloat(peripheralBrightnessInput.value) / 100;
                minOpacity = parseFloat(foveatedDimnessInput.value) / 100;
                mouseSensitivity = parseFloat(mouseSensitivityInput.value) / 1000;
                touchSensitivity = parseFloat(touchSensitivityInput.value) / 1000;
                titleParallaxMultiplier = parseFloat(titleParallaxInput.value) / 100;
                // Music volume is updated on slider input

                // Re-initialize Three.js scene with new settings (for star count and field size)
                initThreeJS();

                // Update fovea indicator size based on new foveaRadius
                foveaIndicator.style.setProperty('--fovea-indicator-size', `${foveaRadius * 2}px`);

                // Hide the settings panel after applying (optional)
                // settingsPanel.classList.remove('visible');
                console.log('Settings applied.');
            });

             // Settings toggle button click handler
             settingsToggle.addEventListener('click', () => {
                 settingsPanel.classList.toggle('visible');
             });


            // --- Initialization ---

            // Initialize Three.js scene and elements
            initThreeJS();

            // Set initial music volume to half of the settings value
            backgroundMusic.volume = (parseFloat(musicVolumeInput.value) / 100) / 2;

             // Add touch event listeners (mobile)
             mainContainer.addEventListener('touchstart', handleTouchStart, false);
             mainContainer.addEventListener('touchmove', handleTouchMove, false);
             mainContainer.addEventListener('touchend', handleTouchEnd, false);

            // Set fovea indicator size based on foveaRadius
            foveaIndicator.style.setProperty('--fovea-indicator-size', `${foveaRadius * 2}px`);

            // Show fovea indicator if it's a touch device
            if (isTouchDevice) {
                foveaIndicator.classList.add('visible');
                 // Update initial message for touch devices
                 userMessage.innerHTML = 'Touch and drag to explore<br>Tap to start music (if needed)';
            } else {
                // On desktop, the fovea indicator is hidden initially and shown only when pointer lock is lost (optional)
                foveaIndicator.classList.remove('visible');
            }


            // Initial update to position HTML elements correctly on load
            updateHtmlElementPositions();

            console.log('Initialization complete.');

            // Attempt to play music automatically on load (might be blocked by autoplay policies)
             backgroundMusic.play().catch(error => {
                 console.log('Autoplay blocked. Music will start on user interaction.');
                 // You could optionally show a message here indicating music requires interaction
             });


            // Optional: Basic responsiveness - handle window resize
            window.addEventListener('resize', () => {
                 console.log('Window resized.');
                 // Exit pointer lock on resize for better handling
                 if (document.pointerLockElement === mainContainer) {
                     document.exitPointerLock();
                 }

                 // Update camera aspect ratio and renderer size
                 camera.aspect = window.innerWidth / window.innerHeight;
                 camera.updateProjectionMatrix();
                 renderer.setSize(window.innerWidth, window.innerHeight);

                 // Update fovea indicator size on resize
                 foveaIndicator.style.setProperty('--fovea-indicator-size', `${foveaRadius * 2}px`);

                 // Update HTML element positions for the new window size
                 updateHtmlElementPositions();

                 // Re-initialize Three.js with current settings on resize (optional, but good for consistent density)
                 // initThreeJS();
            });
        }); // End of DOMContentLoaded listener
    </script>
</body>
</html>
